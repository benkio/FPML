/*
 * generated by Xtext 2.10.0
 */
package it.unibo.serializer;

import com.google.inject.Inject;
import it.unibo.fPML.AdditionalEffectFullArgument;
import it.unibo.fPML.AdditionalPureArgument;
import it.unibo.fPML.ApplyF;
import it.unibo.fPML.ApplyFIO;
import it.unibo.fPML.ApplyFIOFactor;
import it.unibo.fPML.Argument;
import it.unibo.fPML.CompositionFunctionBodyEffect;
import it.unibo.fPML.CompositionFunctionBodyEffectFullFactor;
import it.unibo.fPML.CompositionFunctionBodyPure;
import it.unibo.fPML.CompositionFunctionBodyPureFactor;
import it.unibo.fPML.DataType;
import it.unibo.fPML.DataValue;
import it.unibo.fPML.EffectFullAdtType;
import it.unibo.fPML.EffectFullArgument;
import it.unibo.fPML.EffectFullBlock;
import it.unibo.fPML.EffectFullData;
import it.unibo.fPML.EffectFullDataBlock;
import it.unibo.fPML.EffectFullDataType;
import it.unibo.fPML.EffectFullDataValue;
import it.unibo.fPML.EffectFullFunctionBlock;
import it.unibo.fPML.EffectFullFunctionDefinition;
import it.unibo.fPML.EffectFullFunctionType;
import it.unibo.fPML.EffectFullLambda;
import it.unibo.fPML.EffectFullProdType;
import it.unibo.fPML.EffectFullProdValue;
import it.unibo.fPML.EffectFullSumType;
import it.unibo.fPML.EffectFullSumValue;
import it.unibo.fPML.EffectFullValue;
import it.unibo.fPML.EffectFullValueBlock;
import it.unibo.fPML.EffectFullValueRef;
import it.unibo.fPML.EmptyFunctionBody;
import it.unibo.fPML.FPMLPackage;
import it.unibo.fPML.IOType;
import it.unibo.fPML.IntPow;
import it.unibo.fPML.IntToString;
import it.unibo.fPML.IntegerType;
import it.unibo.fPML.MainFunc;
import it.unibo.fPML.Minus;
import it.unibo.fPML.Mod;
import it.unibo.fPML.Model;
import it.unibo.fPML.Plus;
import it.unibo.fPML.PrimitivePrint;
import it.unibo.fPML.PrimitiveRandom;
import it.unibo.fPML.PureAdtType;
import it.unibo.fPML.PureBlock;
import it.unibo.fPML.PureData;
import it.unibo.fPML.PureDataBlock;
import it.unibo.fPML.PureFunctionBlock;
import it.unibo.fPML.PureFunctionDefinition;
import it.unibo.fPML.PureFunctionType;
import it.unibo.fPML.PureLambda;
import it.unibo.fPML.PureProdType;
import it.unibo.fPML.PureProdValue;
import it.unibo.fPML.PureSumType;
import it.unibo.fPML.PureSumValue;
import it.unibo.fPML.PureValue;
import it.unibo.fPML.PureValueBlock;
import it.unibo.fPML.PureValueRef;
import it.unibo.fPML.StringType;
import it.unibo.fPML.Times;
import it.unibo.fPML.UnitType;
import it.unibo.services.FPMLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class FPMLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FPMLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FPMLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FPMLPackage.ADDITIONAL_EFFECT_FULL_ARGUMENT:
				sequence_AdditionalEffectFullArgument(context, (AdditionalEffectFullArgument) semanticObject); 
				return; 
			case FPMLPackage.ADDITIONAL_PURE_ARGUMENT:
				sequence_AdditionalPureArgument(context, (AdditionalPureArgument) semanticObject); 
				return; 
			case FPMLPackage.APPLY_F:
				sequence_ApplyF(context, (ApplyF) semanticObject); 
				return; 
			case FPMLPackage.APPLY_FIO:
				sequence_ApplyFIO(context, (ApplyFIO) semanticObject); 
				return; 
			case FPMLPackage.APPLY_FIO_FACTOR:
				sequence_ApplyFIOFactor(context, (ApplyFIOFactor) semanticObject); 
				return; 
			case FPMLPackage.ARGUMENT:
				sequence_Argument(context, (Argument) semanticObject); 
				return; 
			case FPMLPackage.COMPOSITION_FUNCTION_BODY_EFFECT:
				sequence_CompositionFunctionBodyEffect(context, (CompositionFunctionBodyEffect) semanticObject); 
				return; 
			case FPMLPackage.COMPOSITION_FUNCTION_BODY_EFFECT_FULL_FACTOR:
				sequence_CompositionFunctionBodyEffectFullFactor(context, (CompositionFunctionBodyEffectFullFactor) semanticObject); 
				return; 
			case FPMLPackage.COMPOSITION_FUNCTION_BODY_PURE:
				sequence_CompositionFunctionBodyPure(context, (CompositionFunctionBodyPure) semanticObject); 
				return; 
			case FPMLPackage.COMPOSITION_FUNCTION_BODY_PURE_FACTOR:
				sequence_CompositionFunctionBodyPureFactor(context, (CompositionFunctionBodyPureFactor) semanticObject); 
				return; 
			case FPMLPackage.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case FPMLPackage.DATA_VALUE:
				sequence_DataValue(context, (DataValue) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_ADT_TYPE:
				sequence_EffectFullAdtType(context, (EffectFullAdtType) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_ARGUMENT:
				sequence_EffectFullArgument(context, (EffectFullArgument) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_BLOCK:
				sequence_EffectFullBlock(context, (EffectFullBlock) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_DATA:
				sequence_EffectFullData(context, (EffectFullData) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_DATA_BLOCK:
				sequence_EffectFullDataBlock(context, (EffectFullDataBlock) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_DATA_TYPE:
				sequence_EffectFullDataType(context, (EffectFullDataType) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_DATA_VALUE:
				sequence_EffectFullDataValue(context, (EffectFullDataValue) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_FUNCTION_BLOCK:
				sequence_EffectFullFunctionBlock(context, (EffectFullFunctionBlock) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_FUNCTION_DEFINITION:
				sequence_EffectFullFunctionDefinition(context, (EffectFullFunctionDefinition) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_FUNCTION_TYPE:
				if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getEffectFullFunctionTypeRule()) {
					sequence_EffectFullFunctionType(context, (EffectFullFunctionType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEffectFullExpressionRule()
						|| rule == grammarAccess.getEffectFullFunctionValueRule()
						|| rule == grammarAccess.getEffectFullAdtValueRule()) {
					sequence_EffectFullFunctionValue(context, (EffectFullFunctionType) semanticObject); 
					return; 
				}
				else break;
			case FPMLPackage.EFFECT_FULL_LAMBDA:
				sequence_EffectFullLambda(context, (EffectFullLambda) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_PROD_TYPE:
				sequence_EffectFullProdType(context, (EffectFullProdType) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_PROD_VALUE:
				sequence_EffectFullProdValue(context, (EffectFullProdValue) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_SUM_TYPE:
				sequence_EffectFullSumType(context, (EffectFullSumType) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_SUM_VALUE:
				sequence_EffectFullSumValue(context, (EffectFullSumValue) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_VALUE:
				sequence_EffectFullValue(context, (EffectFullValue) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_VALUE_BLOCK:
				sequence_EffectFullValueBlock(context, (EffectFullValueBlock) semanticObject); 
				return; 
			case FPMLPackage.EFFECT_FULL_VALUE_REF:
				sequence_EffectFullValueRef(context, (EffectFullValueRef) semanticObject); 
				return; 
			case FPMLPackage.EMPTY_FUNCTION_BODY:
				sequence_EmptyFunctionBody(context, (EmptyFunctionBody) semanticObject); 
				return; 
			case FPMLPackage.IO_TYPE:
				sequence_IOType(context, (IOType) semanticObject); 
				return; 
			case FPMLPackage.INT_POW:
				sequence_IntPow(context, (IntPow) semanticObject); 
				return; 
			case FPMLPackage.INT_TO_STRING:
				sequence_IntToString(context, (IntToString) semanticObject); 
				return; 
			case FPMLPackage.INTEGER_TYPE:
				if (rule == grammarAccess.getEffectFullExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getIntValueRule()
						|| rule == grammarAccess.getPureAdtValueRule()
						|| rule == grammarAccess.getEffectFullAdtValueRule()) {
					sequence_IntValue(context, (IntegerType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPureAdtTypeRule()
						|| rule == grammarAccess.getValueTypeRule()
						|| rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getIntegerTypeRule()) {
					sequence_IntegerType(context, (IntegerType) semanticObject); 
					return; 
				}
				else break;
			case FPMLPackage.MAIN_FUNC:
				sequence_MainFunc(context, (MainFunc) semanticObject); 
				return; 
			case FPMLPackage.MINUS:
				sequence_Minus(context, (Minus) semanticObject); 
				return; 
			case FPMLPackage.MOD:
				sequence_Mod(context, (Mod) semanticObject); 
				return; 
			case FPMLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case FPMLPackage.PLUS:
				sequence_Plus(context, (Plus) semanticObject); 
				return; 
			case FPMLPackage.PRIMITIVE_PRINT:
				sequence_PrimitivePrint(context, (PrimitivePrint) semanticObject); 
				return; 
			case FPMLPackage.PRIMITIVE_RANDOM:
				sequence_PrimitiveRandom(context, (PrimitiveRandom) semanticObject); 
				return; 
			case FPMLPackage.PURE_ADT_TYPE:
				sequence_PureAdtType(context, (PureAdtType) semanticObject); 
				return; 
			case FPMLPackage.PURE_BLOCK:
				sequence_PureBlock(context, (PureBlock) semanticObject); 
				return; 
			case FPMLPackage.PURE_DATA:
				sequence_PureData(context, (PureData) semanticObject); 
				return; 
			case FPMLPackage.PURE_DATA_BLOCK:
				sequence_PureDataBlock(context, (PureDataBlock) semanticObject); 
				return; 
			case FPMLPackage.PURE_FUNCTION_BLOCK:
				sequence_PureFunctionBlock(context, (PureFunctionBlock) semanticObject); 
				return; 
			case FPMLPackage.PURE_FUNCTION_DEFINITION:
				sequence_PureFunctionDefinition(context, (PureFunctionDefinition) semanticObject); 
				return; 
			case FPMLPackage.PURE_FUNCTION_TYPE:
				if (rule == grammarAccess.getEffectFullExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getFunctionValueRule()
						|| rule == grammarAccess.getPureAdtValueRule()
						|| rule == grammarAccess.getEffectFullAdtValueRule()) {
					sequence_FunctionValue(context, (PureFunctionType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPureAdtTypeRule()
						|| rule == grammarAccess.getValueTypeRule()
						|| rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getPureFunctionTypeRule()) {
					sequence_PureFunctionType(context, (PureFunctionType) semanticObject); 
					return; 
				}
				else break;
			case FPMLPackage.PURE_LAMBDA:
				sequence_PureLambda(context, (PureLambda) semanticObject); 
				return; 
			case FPMLPackage.PURE_PROD_TYPE:
				sequence_PureProdType(context, (PureProdType) semanticObject); 
				return; 
			case FPMLPackage.PURE_PROD_VALUE:
				sequence_PureProdValue(context, (PureProdValue) semanticObject); 
				return; 
			case FPMLPackage.PURE_SUM_TYPE:
				sequence_PureSumType(context, (PureSumType) semanticObject); 
				return; 
			case FPMLPackage.PURE_SUM_VALUE:
				sequence_PureSumValue(context, (PureSumValue) semanticObject); 
				return; 
			case FPMLPackage.PURE_VALUE:
				sequence_PureValue(context, (PureValue) semanticObject); 
				return; 
			case FPMLPackage.PURE_VALUE_BLOCK:
				sequence_PureValueBlock(context, (PureValueBlock) semanticObject); 
				return; 
			case FPMLPackage.PURE_VALUE_REF:
				sequence_PureValueRef(context, (PureValueRef) semanticObject); 
				return; 
			case FPMLPackage.STRING_TYPE:
				if (rule == grammarAccess.getPureAdtTypeRule()
						|| rule == grammarAccess.getValueTypeRule()
						|| rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getStringTypeRule()) {
					sequence_StringType(context, (StringType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEffectFullExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getStringValueRule()
						|| rule == grammarAccess.getPureAdtValueRule()
						|| rule == grammarAccess.getEffectFullAdtValueRule()) {
					sequence_StringValue(context, (StringType) semanticObject); 
					return; 
				}
				else break;
			case FPMLPackage.TIMES:
				sequence_Times(context, (Times) semanticObject); 
				return; 
			case FPMLPackage.UNIT_TYPE:
				if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getUnitTypeRule()) {
					sequence_UnitType(context, (UnitType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEffectFullExpressionRule()
						|| rule == grammarAccess.getUnitValueRule()
						|| rule == grammarAccess.getEffectFullAdtValueRule()) {
					sequence_UnitValue(context, (UnitType) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AdditionalEffectFullArgument returns AdditionalEffectFullArgument
	 *
	 * Constraint:
	 *     arg2=EffectFullArgument
	 */
	protected void sequence_AdditionalEffectFullArgument(ISerializationContext context, AdditionalEffectFullArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.ADDITIONAL_EFFECT_FULL_ARGUMENT__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.ADDITIONAL_EFFECT_FULL_ARGUMENT__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionalEffectFullArgumentAccess().getArg2EffectFullArgumentParserRuleCall_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AdditionalPureArgument returns AdditionalPureArgument
	 *
	 * Constraint:
	 *     arg2=Argument
	 */
	protected void sequence_AdditionalPureArgument(ISerializationContext context, AdditionalPureArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.ADDITIONAL_PURE_ARGUMENT__ARG2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.ADDITIONAL_PURE_ARGUMENT__ARG2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionalPureArgumentAccess().getArg2ArgumentParserRuleCall_0(), semanticObject.getArg2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ApplyFIOFactor returns ApplyFIOFactor
	 *
	 * Constraint:
	 *     (valueReference=[EffectFullReference|ID] | valuePrimitive=PrimitiveEffectFullValue)
	 */
	protected void sequence_ApplyFIOFactor(ISerializationContext context, ApplyFIOFactor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns ApplyFIO
	 *     EffectFullFunction returns ApplyFIO
	 *     EffectFullReference returns ApplyFIO
	 *     PrimitiveFunction returns ApplyFIO
	 *     PrimitiveEffectFullFunction returns ApplyFIO
	 *     ApplyFIO returns ApplyFIO
	 *
	 * Constraint:
	 *     (functionType=EffectFullFunctionType value=ApplyFIOFactor)
	 */
	protected void sequence_ApplyFIO(ISerializationContext context, ApplyFIO semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.APPLY_FIO__FUNCTION_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.APPLY_FIO__FUNCTION_TYPE));
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.APPLY_FIO__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.APPLY_FIO__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getApplyFIOAccess().getFunctionTypeEffectFullFunctionTypeParserRuleCall_2_0(), semanticObject.getFunctionType());
		feeder.accept(grammarAccess.getApplyFIOAccess().getValueApplyFIOFactorParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Function returns ApplyF
	 *     PureFunction returns ApplyF
	 *     EffectFullReference returns ApplyF
	 *     PrimitiveFunction returns ApplyF
	 *     PrimitivePureFunction returns ApplyF
	 *     ApplyF returns ApplyF
	 *
	 * Constraint:
	 *     (functionType=PureFunctionType value=[PureReference|ID])
	 */
	protected void sequence_ApplyF(ISerializationContext context, ApplyF semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.APPLY_F__FUNCTION_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.APPLY_F__FUNCTION_TYPE));
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.APPLY_F__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.APPLY_F__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getApplyFAccess().getFunctionTypePureFunctionTypeParserRuleCall_2_0(), semanticObject.getFunctionType());
		feeder.accept(grammarAccess.getApplyFAccess().getValuePureReferenceIDTerminalRuleCall_3_0_1(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PureReference returns Argument
	 *     Argument returns Argument
	 *
	 * Constraint:
	 *     (type=ValueType name=ID)
	 */
	protected void sequence_Argument(ISerializationContext context, Argument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.ARGUMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.ARGUMENT__TYPE));
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.PURE_REFERENCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.PURE_REFERENCE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArgumentAccess().getTypeValueTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getArgumentAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompositionFunctionBodyEffectFullFactor returns CompositionFunctionBodyEffectFullFactor
	 *
	 * Constraint:
	 *     (referenceElement=[EffectFullReference|ID] | PrimitiveElement=PrimitiveFunction)
	 */
	protected void sequence_CompositionFunctionBodyEffectFullFactor(ISerializationContext context, CompositionFunctionBodyEffectFullFactor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionBodyEffectFull returns CompositionFunctionBodyEffect
	 *     CompositionFunctionBodyEffect returns CompositionFunctionBodyEffect
	 *
	 * Constraint:
	 *     (
	 *         (referenceElement=[EffectFullReference|ID] functionChain+=CompositionFunctionBodyEffectFullFactor+) | 
	 *         (primitiveElement=PrimitiveFunction functionChain+=CompositionFunctionBodyEffectFullFactor+)
	 *     )
	 */
	protected void sequence_CompositionFunctionBodyEffect(ISerializationContext context, CompositionFunctionBodyEffect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompositionFunctionBodyPureFactor returns CompositionFunctionBodyPureFactor
	 *
	 * Constraint:
	 *     (referenceElement=[PureFunctionDefinition|ID] | PrimitiveElement=PrimitivePureFunction)
	 */
	protected void sequence_CompositionFunctionBodyPureFactor(ISerializationContext context, CompositionFunctionBodyPureFactor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionBodyPure returns CompositionFunctionBodyPure
	 *     CompositionFunctionBodyPure returns CompositionFunctionBodyPure
	 *
	 * Constraint:
	 *     (
	 *         (referenceElement=[PureFunctionDefinition|ID] functionChain+=CompositionFunctionBodyPureFactor+) | 
	 *         (primitiveElement=PrimitivePureFunction functionChain+=CompositionFunctionBodyPureFactor+)
	 *     )
	 */
	protected void sequence_CompositionFunctionBodyPure(ISerializationContext context, CompositionFunctionBodyPure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PureAdtType returns DataType
	 *     ValueType returns DataType
	 *     Type returns DataType
	 *     DataType returns DataType
	 *
	 * Constraint:
	 *     type=[PureData|ID]
	 */
	protected void sequence_DataType(ISerializationContext context, DataType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.DATA_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.DATA_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataTypeAccess().getTypePureDataIDTerminalRuleCall_2_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullExpression returns DataValue
	 *     Expression returns DataValue
	 *     DataValue returns DataValue
	 *     PureAdtValue returns DataValue
	 *     EffectFullAdtValue returns DataValue
	 *
	 * Constraint:
	 *     (type=[PureData|ID] value=PureAdtValue)
	 */
	protected void sequence_DataValue(ISerializationContext context, DataValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.DATA_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.DATA_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.DATA_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.DATA_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataValueAccess().getTypePureDataIDTerminalRuleCall_1_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getDataValueAccess().getValuePureAdtValueParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullAdtType returns EffectFullAdtType
	 *
	 * Constraint:
	 *     (effectFullAdtElement1=EffectFullAdtType (effectFullAdtElement2=EffectFullSumType | effectFullAdtElement2=EffectFullProdType))
	 */
	protected void sequence_EffectFullAdtType(ISerializationContext context, EffectFullAdtType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullReference returns EffectFullArgument
	 *     EffectFullArgument returns EffectFullArgument
	 *
	 * Constraint:
	 *     (type=Type name=ID)
	 */
	protected void sequence_EffectFullArgument(ISerializationContext context, EffectFullArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_ARGUMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_ARGUMENT__TYPE));
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_ARGUMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_ARGUMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEffectFullArgumentAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getEffectFullArgumentAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullBlock returns EffectFullBlock
	 *
	 * Constraint:
	 *     (elements+=EffectFullDataBlock elements+=EffectFullFunctionBlock)
	 */
	protected void sequence_EffectFullBlock(ISerializationContext context, EffectFullBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullDataBlock returns EffectFullDataBlock
	 *
	 * Constraint:
	 *     (elements+=EffectFullData* value=EffectFullValueBlock)
	 */
	protected void sequence_EffectFullDataBlock(ISerializationContext context, EffectFullDataBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns EffectFullDataType
	 *     EffectFullDataType returns EffectFullDataType
	 *
	 * Constraint:
	 *     type=[EffectFullData|ID]
	 */
	protected void sequence_EffectFullDataType(ISerializationContext context, EffectFullDataType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_DATA_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_DATA_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEffectFullDataTypeAccess().getTypeEffectFullDataIDTerminalRuleCall_2_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullExpression returns EffectFullDataValue
	 *     EffectFullDataValue returns EffectFullDataValue
	 *
	 * Constraint:
	 *     (type=[EffectFullData|ID] value=EffectFullAdtValue)
	 */
	protected void sequence_EffectFullDataValue(ISerializationContext context, EffectFullDataValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_DATA_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_DATA_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_DATA_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_DATA_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEffectFullDataValueAccess().getTypeEffectFullDataIDTerminalRuleCall_1_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getEffectFullDataValueAccess().getValueEffectFullAdtValueParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullData returns EffectFullData
	 *
	 * Constraint:
	 *     (name=ID content=EffectFullAdtType)
	 */
	protected void sequence_EffectFullData(ISerializationContext context, EffectFullData semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_DATA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_DATA__NAME));
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_DATA__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_DATA__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEffectFullDataAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEffectFullDataAccess().getContentEffectFullAdtTypeParserRuleCall_2_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullFunctionBlock returns EffectFullFunctionBlock
	 *
	 * Constraint:
	 *     (features+=EffectFullFunctionDefinition* main=MainFunc)
	 */
	protected void sequence_EffectFullFunctionBlock(ISerializationContext context, EffectFullFunctionBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullFunctionDefinition returns EffectFullFunctionDefinition
	 *     Function returns EffectFullFunctionDefinition
	 *     EffectFullFunction returns EffectFullFunctionDefinition
	 *
	 * Constraint:
	 *     (returnType=IOType name=ID arg=EffectFullArgument higherOrderArg=AdditionalEffectFullArgument? functionBody=FunctionBodyEffectFull)
	 */
	protected void sequence_EffectFullFunctionDefinition(ISerializationContext context, EffectFullFunctionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns EffectFullFunctionType
	 *     EffectFullFunctionType returns EffectFullFunctionType
	 *
	 * Constraint:
	 *     (argType=Type returnType=IOType)
	 */
	protected void sequence_EffectFullFunctionType(ISerializationContext context, EffectFullFunctionType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_FUNCTION_TYPE__ARG_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_FUNCTION_TYPE__ARG_TYPE));
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_FUNCTION_TYPE__RETURN_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_FUNCTION_TYPE__RETURN_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEffectFullFunctionTypeAccess().getArgTypeTypeParserRuleCall_3_0(), semanticObject.getArgType());
		feeder.accept(grammarAccess.getEffectFullFunctionTypeAccess().getReturnTypeIOTypeParserRuleCall_5_0(), semanticObject.getReturnType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullExpression returns EffectFullFunctionType
	 *     EffectFullFunctionValue returns EffectFullFunctionType
	 *     EffectFullAdtValue returns EffectFullFunctionType
	 *
	 * Constraint:
	 *     value=EffectFullLambda
	 */
	protected void sequence_EffectFullFunctionValue(ISerializationContext context, EffectFullFunctionType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_FUNCTION_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_FUNCTION_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEffectFullFunctionValueAccess().getValueEffectFullLambdaParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullLambda returns EffectFullLambda
	 *
	 * Constraint:
	 *     ((arg=EffectFullArgument functionBody=FunctionBodyEffectFull) | functionBody=FunctionBodyEffectFull)
	 */
	protected void sequence_EffectFullLambda(ISerializationContext context, EffectFullLambda semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullProdType returns EffectFullProdType
	 *
	 * Constraint:
	 *     adtElement=EffectFullAdtType
	 */
	protected void sequence_EffectFullProdType(ISerializationContext context, EffectFullProdType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_PROD_TYPE__ADT_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_PROD_TYPE__ADT_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEffectFullProdTypeAccess().getAdtElementEffectFullAdtTypeParserRuleCall_1_0(), semanticObject.getAdtElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullAdtValue returns EffectFullProdValue
	 *     EffectFullProdValue returns EffectFullProdValue
	 *
	 * Constraint:
	 *     (prodAdtElement1=EffectFullAdtValue prodAdtElement2=EffectFullAdtValue)
	 */
	protected void sequence_EffectFullProdValue(ISerializationContext context, EffectFullProdValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_PROD_VALUE__PROD_ADT_ELEMENT1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_PROD_VALUE__PROD_ADT_ELEMENT1));
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_PROD_VALUE__PROD_ADT_ELEMENT2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_PROD_VALUE__PROD_ADT_ELEMENT2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEffectFullProdValueAccess().getProdAdtElement1EffectFullAdtValueParserRuleCall_1_0(), semanticObject.getProdAdtElement1());
		feeder.accept(grammarAccess.getEffectFullProdValueAccess().getProdAdtElement2EffectFullAdtValueParserRuleCall_3_0(), semanticObject.getProdAdtElement2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullSumType returns EffectFullSumType
	 *
	 * Constraint:
	 *     adtElement=EffectFullAdtType
	 */
	protected void sequence_EffectFullSumType(ISerializationContext context, EffectFullSumType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_SUM_TYPE__ADT_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_SUM_TYPE__ADT_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEffectFullSumTypeAccess().getAdtElementEffectFullAdtTypeParserRuleCall_1_0(), semanticObject.getAdtElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullAdtValue returns EffectFullSumValue
	 *     EffectFullSumValue returns EffectFullSumValue
	 *
	 * Constraint:
	 *     (sumAdtElement1=EffectFullAdtValue | sumAdtElement2=EffectFullAdtValue)
	 */
	protected void sequence_EffectFullSumValue(ISerializationContext context, EffectFullSumValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullValueBlock returns EffectFullValueBlock
	 *
	 * Constraint:
	 *     elements+=EffectFullValue+
	 */
	protected void sequence_EffectFullValueBlock(ISerializationContext context, EffectFullValueBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullValueRef returns EffectFullValueRef
	 *     EffectFullAdtValue returns EffectFullValueRef
	 *
	 * Constraint:
	 *     value=[EffectFullValue|ID]
	 */
	protected void sequence_EffectFullValueRef(ISerializationContext context, EffectFullValueRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_VALUE_REF__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_VALUE_REF__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEffectFullValueRefAccess().getValueEffectFullValueIDTerminalRuleCall_1_0_1(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullValue returns EffectFullValue
	 *     EffectFullReference returns EffectFullValue
	 *
	 * Constraint:
	 *     (name=ID value=EffectFullExpression)
	 */
	protected void sequence_EffectFullValue(ISerializationContext context, EffectFullValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_FUNCTION_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_FUNCTION_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.EFFECT_FULL_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.EFFECT_FULL_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEffectFullValueAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEffectFullValueAccess().getValueEffectFullExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionBodyPure returns EmptyFunctionBody
	 *     FunctionBodyEffectFull returns EmptyFunctionBody
	 *     EmptyFunctionBody returns EmptyFunctionBody
	 *
	 * Constraint:
	 *     {EmptyFunctionBody}
	 */
	protected void sequence_EmptyFunctionBody(ISerializationContext context, EmptyFunctionBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullExpression returns PureFunctionType
	 *     Expression returns PureFunctionType
	 *     FunctionValue returns PureFunctionType
	 *     PureAdtValue returns PureFunctionType
	 *     EffectFullAdtValue returns PureFunctionType
	 *
	 * Constraint:
	 *     value=PureLambda
	 */
	protected void sequence_FunctionValue(ISerializationContext context, PureFunctionType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.PURE_FUNCTION_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.PURE_FUNCTION_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionValueAccess().getValuePureLambdaParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullAdtType returns IOType
	 *     IOType returns IOType
	 *
	 * Constraint:
	 *     type=Type
	 */
	protected void sequence_IOType(ISerializationContext context, IOType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.IO_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.IO_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIOTypeAccess().getTypeTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Function returns IntPow
	 *     PureFunction returns IntPow
	 *     EffectFullReference returns IntPow
	 *     PrimitiveFunction returns IntPow
	 *     PrimitivePureFunction returns IntPow
	 *     IntPow returns IntPow
	 *
	 * Constraint:
	 *     {IntPow}
	 */
	protected void sequence_IntPow(ISerializationContext context, IntPow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns IntToString
	 *     PureFunction returns IntToString
	 *     EffectFullReference returns IntToString
	 *     PrimitiveFunction returns IntToString
	 *     PrimitivePureFunction returns IntToString
	 *     IntToString returns IntToString
	 *
	 * Constraint:
	 *     {IntToString}
	 */
	protected void sequence_IntToString(ISerializationContext context, IntToString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullExpression returns IntegerType
	 *     Expression returns IntegerType
	 *     IntValue returns IntegerType
	 *     PureAdtValue returns IntegerType
	 *     EffectFullAdtValue returns IntegerType
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntValue(ISerializationContext context, IntegerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.INTEGER_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.INTEGER_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntValueAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PureAdtType returns IntegerType
	 *     ValueType returns IntegerType
	 *     Type returns IntegerType
	 *     IntegerType returns IntegerType
	 *
	 * Constraint:
	 *     type='int'
	 */
	protected void sequence_IntegerType(ISerializationContext context, IntegerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.INTEGER_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.INTEGER_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerTypeAccess().getTypeIntKeyword_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MainFunc returns MainFunc
	 *
	 * Constraint:
	 *     (returnType=UnitType functionBody=FunctionBodyEffectFull)
	 */
	protected void sequence_MainFunc(ISerializationContext context, MainFunc semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.MAIN_FUNC__RETURN_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.MAIN_FUNC__RETURN_TYPE));
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.MAIN_FUNC__FUNCTION_BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.MAIN_FUNC__FUNCTION_BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMainFuncAccess().getReturnTypeUnitTypeParserRuleCall_1_0(), semanticObject.getReturnType());
		feeder.accept(grammarAccess.getMainFuncAccess().getFunctionBodyFunctionBodyEffectFullParserRuleCall_5_0(), semanticObject.getFunctionBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Minus
	 *     PureFunction returns Minus
	 *     EffectFullReference returns Minus
	 *     PrimitiveFunction returns Minus
	 *     PrimitivePureFunction returns Minus
	 *     Minus returns Minus
	 *
	 * Constraint:
	 *     {Minus}
	 */
	protected void sequence_Minus(ISerializationContext context, Minus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Mod
	 *     PureFunction returns Mod
	 *     EffectFullReference returns Mod
	 *     PrimitiveFunction returns Mod
	 *     PrimitivePureFunction returns Mod
	 *     Mod returns Mod
	 *
	 * Constraint:
	 *     {Mod}
	 */
	protected void sequence_Mod(ISerializationContext context, Mod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (elements+=PureBlock elements+=EffectFullBlock)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Plus
	 *     PureFunction returns Plus
	 *     EffectFullReference returns Plus
	 *     PrimitiveFunction returns Plus
	 *     PrimitivePureFunction returns Plus
	 *     Plus returns Plus
	 *
	 * Constraint:
	 *     {Plus}
	 */
	protected void sequence_Plus(ISerializationContext context, Plus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns PrimitivePrint
	 *     EffectFullFunction returns PrimitivePrint
	 *     EffectFullReference returns PrimitivePrint
	 *     PrimitiveFunction returns PrimitivePrint
	 *     PrimitiveEffectFullFunction returns PrimitivePrint
	 *     PrimitivePrint returns PrimitivePrint
	 *
	 * Constraint:
	 *     {PrimitivePrint}
	 */
	protected void sequence_PrimitivePrint(ISerializationContext context, PrimitivePrint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullReference returns PrimitiveRandom
	 *     PrimitiveEffectFullValue returns PrimitiveRandom
	 *     PrimitiveRandom returns PrimitiveRandom
	 *
	 * Constraint:
	 *     {PrimitiveRandom}
	 */
	protected void sequence_PrimitiveRandom(ISerializationContext context, PrimitiveRandom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PureAdtType returns PureAdtType
	 *
	 * Constraint:
	 *     (pureAdtElement1=PureAdtType (pureAdtElement2=PureSumType | pureAdtElement2=PureProdType))
	 */
	protected void sequence_PureAdtType(ISerializationContext context, PureAdtType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PureBlock returns PureBlock
	 *
	 * Constraint:
	 *     (elements+=PureDataBlock elements+=PureFunctionBlock)
	 */
	protected void sequence_PureBlock(ISerializationContext context, PureBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PureDataBlock returns PureDataBlock
	 *
	 * Constraint:
	 *     (elements+=PureData* value=PureValueBlock)
	 */
	protected void sequence_PureDataBlock(ISerializationContext context, PureDataBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PureData returns PureData
	 *
	 * Constraint:
	 *     (name=ID content=PureAdtType)
	 */
	protected void sequence_PureData(ISerializationContext context, PureData semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.PURE_DATA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.PURE_DATA__NAME));
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.PURE_DATA__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.PURE_DATA__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPureDataAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPureDataAccess().getContentPureAdtTypeParserRuleCall_2_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PureFunctionBlock returns PureFunctionBlock
	 *
	 * Constraint:
	 *     features+=PureFunctionDefinition+
	 */
	protected void sequence_PureFunctionBlock(ISerializationContext context, PureFunctionBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PureFunctionDefinition returns PureFunctionDefinition
	 *     Function returns PureFunctionDefinition
	 *     PureFunction returns PureFunctionDefinition
	 *
	 * Constraint:
	 *     (returnType=ValueType name=ID arg=Argument higherOrderArg=AdditionalPureArgument? functionBody=FunctionBodyPure)
	 */
	protected void sequence_PureFunctionDefinition(ISerializationContext context, PureFunctionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PureAdtType returns PureFunctionType
	 *     ValueType returns PureFunctionType
	 *     Type returns PureFunctionType
	 *     PureFunctionType returns PureFunctionType
	 *
	 * Constraint:
	 *     (argType=ValueType returnType=ValueType)
	 */
	protected void sequence_PureFunctionType(ISerializationContext context, PureFunctionType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.PURE_FUNCTION_TYPE__ARG_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.PURE_FUNCTION_TYPE__ARG_TYPE));
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.PURE_FUNCTION_TYPE__RETURN_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.PURE_FUNCTION_TYPE__RETURN_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPureFunctionTypeAccess().getArgTypeValueTypeParserRuleCall_3_0(), semanticObject.getArgType());
		feeder.accept(grammarAccess.getPureFunctionTypeAccess().getReturnTypeValueTypeParserRuleCall_5_0(), semanticObject.getReturnType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PureLambda returns PureLambda
	 *
	 * Constraint:
	 *     (arg=Argument functionBody=FunctionBodyPure)
	 */
	protected void sequence_PureLambda(ISerializationContext context, PureLambda semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.PURE_FUNCTION_DEFINITION__ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.PURE_FUNCTION_DEFINITION__ARG));
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.PURE_FUNCTION_DEFINITION__FUNCTION_BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.PURE_FUNCTION_DEFINITION__FUNCTION_BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPureLambdaAccess().getArgArgumentParserRuleCall_2_0(), semanticObject.getArg());
		feeder.accept(grammarAccess.getPureLambdaAccess().getFunctionBodyFunctionBodyPureParserRuleCall_5_0(), semanticObject.getFunctionBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PureProdType returns PureProdType
	 *
	 * Constraint:
	 *     adtElement=PureAdtType
	 */
	protected void sequence_PureProdType(ISerializationContext context, PureProdType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.PURE_PROD_TYPE__ADT_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.PURE_PROD_TYPE__ADT_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPureProdTypeAccess().getAdtElementPureAdtTypeParserRuleCall_1_0(), semanticObject.getAdtElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PureAdtValue returns PureProdValue
	 *     PureProdValue returns PureProdValue
	 *     EffectFullAdtValue returns PureProdValue
	 *
	 * Constraint:
	 *     (prodAdtElement1=PureAdtValue prodAdtElement2=PureAdtValue)
	 */
	protected void sequence_PureProdValue(ISerializationContext context, PureProdValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.PURE_PROD_VALUE__PROD_ADT_ELEMENT1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.PURE_PROD_VALUE__PROD_ADT_ELEMENT1));
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.PURE_PROD_VALUE__PROD_ADT_ELEMENT2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.PURE_PROD_VALUE__PROD_ADT_ELEMENT2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPureProdValueAccess().getProdAdtElement1PureAdtValueParserRuleCall_1_0(), semanticObject.getProdAdtElement1());
		feeder.accept(grammarAccess.getPureProdValueAccess().getProdAdtElement2PureAdtValueParserRuleCall_3_0(), semanticObject.getProdAdtElement2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PureSumType returns PureSumType
	 *
	 * Constraint:
	 *     adtElement=PureAdtType
	 */
	protected void sequence_PureSumType(ISerializationContext context, PureSumType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.PURE_SUM_TYPE__ADT_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.PURE_SUM_TYPE__ADT_ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPureSumTypeAccess().getAdtElementPureAdtTypeParserRuleCall_1_0(), semanticObject.getAdtElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PureAdtValue returns PureSumValue
	 *     PureSumValue returns PureSumValue
	 *     EffectFullAdtValue returns PureSumValue
	 *
	 * Constraint:
	 *     (sumAdtElement1=PureAdtValue | sumAdtElement2=PureAdtValue)
	 */
	protected void sequence_PureSumValue(ISerializationContext context, PureSumValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PureValueBlock returns PureValueBlock
	 *
	 * Constraint:
	 *     elements+=PureValue+
	 */
	protected void sequence_PureValueBlock(ISerializationContext context, PureValueBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PureValueRef returns PureValueRef
	 *     PureAdtValue returns PureValueRef
	 *     EffectFullAdtValue returns PureValueRef
	 *
	 * Constraint:
	 *     value=[PureValue|ID]
	 */
	protected void sequence_PureValueRef(ISerializationContext context, PureValueRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.PURE_VALUE_REF__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.PURE_VALUE_REF__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPureValueRefAccess().getValuePureValueIDTerminalRuleCall_1_0_1(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PureValue returns PureValue
	 *     EffectFullReference returns PureValue
	 *     PureReference returns PureValue
	 *
	 * Constraint:
	 *     (name=ID value=Expression)
	 */
	protected void sequence_PureValue(ISerializationContext context, PureValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.PURE_REFERENCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.PURE_REFERENCE__NAME));
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.PURE_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.PURE_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPureValueAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPureValueAccess().getValueExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PureAdtType returns StringType
	 *     ValueType returns StringType
	 *     Type returns StringType
	 *     StringType returns StringType
	 *
	 * Constraint:
	 *     type='String'
	 */
	protected void sequence_StringType(ISerializationContext context, StringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.STRING_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.STRING_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringTypeAccess().getTypeStringKeyword_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullExpression returns StringType
	 *     Expression returns StringType
	 *     StringValue returns StringType
	 *     PureAdtValue returns StringType
	 *     EffectFullAdtValue returns StringType
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringValue(ISerializationContext context, StringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.STRING_TYPE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.STRING_TYPE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringValueAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Times
	 *     PureFunction returns Times
	 *     EffectFullReference returns Times
	 *     PrimitiveFunction returns Times
	 *     PrimitivePureFunction returns Times
	 *     Times returns Times
	 *
	 * Constraint:
	 *     {Times}
	 */
	protected void sequence_Times(ISerializationContext context, Times semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns UnitType
	 *     UnitType returns UnitType
	 *
	 * Constraint:
	 *     type='Unit'
	 */
	protected void sequence_UnitType(ISerializationContext context, UnitType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FPMLPackage.Literals.UNIT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FPMLPackage.Literals.UNIT_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnitTypeAccess().getTypeUnitKeyword_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EffectFullExpression returns UnitType
	 *     UnitValue returns UnitType
	 *     EffectFullAdtValue returns UnitType
	 *
	 * Constraint:
	 *     {UnitType}
	 */
	protected void sequence_UnitValue(ISerializationContext context, UnitType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
