/*
 * generated by Xtext 2.9.2
 */
package it.unibo.validation

import it.unibo.fPML.*
import org.eclipse.xtext.validation.Check
import org.eclipse.emf.ecore.util.EcoreUtil

import org.eclipse.emf.ecore.EObject
import it.unibo.validation.utilitiesFunctions.*
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class FPMLValidator extends AbstractFPMLValidator {

    public static val TYPEMISMATCHFUNCTIONCOMPOSITION = "Type mismatch between the input of one function and the return of another in the function chain";
    public static val TYPEMISMATCHFUNCTIONCOMPOSITIONRETURN = "The return type of the last function and the outside function doesn't match";
    public static val TYPEMISMATCHFUNCTIONCOMPOSITIONLAMBDA = "The first argument of the product type in the lambda function chain doesn't match the return type of the function before the lambda"
    public static val TYPEMISMATCHFUNCTIONCOMPOSITIONARGS = "The argument type of the function is not the same as the first argument of the function chain";
    public static val EFFECTFULLARGUMENTUNITTYPEID = "The Unit Type don't require and ID";
    public static val TYPEVMISMATCHBETWEENVALUEANDDATA = "The value doesn't match the data declaration"
	public static val APPLYFUNCTIONTOWRONGVALUE = "The function is APPLYF has a wrong value type"
	
    @Check
    def CompositionFunctionTypePure(CompositionFunctionBodyPure cfbp ) {
    	var ValueType t = GetReturnType.getReturnValueType(Others.getFirstFunctionDefinitionFromCompositionBodyPure(cfbp), GetArgType.getArgTypeCompositionFunctionBodyPureContainer(cfbp));
                	
        for (CompositionFunctionBodyPureFactor pf : cfbp.getFunctionChain()){
	        var ValueType t1 = GetArgType.getArgTypePure(Others.getFunctionDefinitionFromPureFactor(pf), t);
	             	    
	        if(!Checks.checkValueTypeEquals(t, t1))
	           error(TYPEMISMATCHFUNCTIONCOMPOSITION, FPMLPackage.Literals.COMPOSITION_FUNCTION_BODY_PURE__FUNCTION_CHAIN );
            t = GetReturnType.getReturnValueType(Others.getFunctionDefinitionFromPureFactor(pf), t)
        }
        
        if (cfbp.returnFunction != null) {
        		val firstElem = cfbp.returnFunction.lambdaFunctionBody.arg.type 
        		if (!Checks.isInputTypeCompatibleWithArgType(firstElem,t))
     			error(TYPEMISMATCHFUNCTIONCOMPOSITIONLAMBDA, FPMLPackage.Literals.COMPOSITION_FUNCTION_BODY_PURE__FUNCTION_CHAIN)
        }
    }

    @Check
    def CompositionFunctionTypeEffect(CompositionFunctionBodyEffect cfbe ) {
        var Type t = GetReturnType.getReturnType(Others.getFirstFunctionDefinitionFromCompositionBodyEffectFull(cfbe), GetArgType.getArgTypeCompositionFunctionBodyEffectFullContainer(cfbe))
        
        for (CompositionFunctionBodyEffectFullFactor ef : cfbe.getFunctionChain()) {
        	val efElement = Others.getFunctionDefinitionFromEffectFullFactor(ef)
            if (!(efElement instanceof Value) && !(efElement instanceof EffectFullArgument)) {
                val Type t1 = GetArgType.getArgType(efElement, t); 
                if(!Checks.checkTypeEquals(t, t1))
                    error(TYPEMISMATCHFUNCTIONCOMPOSITION, FPMLPackage.Literals.COMPOSITION_FUNCTION_BODY_EFFECT__FUNCTION_CHAIN);
            }
            t = GetReturnType.getReturnType(efElement, t);
        }
        
        if (cfbe.returnFunction != null) {
          		val firstElem = cfbe.returnFunction.lambdaFunctionBody.arg.type 
        		if (!Checks.isInputTypeCompatibleWithArgType(firstElem,t))
     			error(TYPEMISMATCHFUNCTIONCOMPOSITIONLAMBDA, FPMLPackage.Literals.COMPOSITION_FUNCTION_BODY_PURE__FUNCTION_CHAIN)
        	}
    }

    @Check
    def FunctionCompositionReturnType(PureFunctionDefinition pf){
        val rt = pf.getFunctionBody();
        if (rt != null && rt instanceof CompositionFunctionBodyPure) {
            val rt2 = GetReturnType.getReturnTypeCompositionFunctionBodyPureFunctionDefinition(pf)
            if(!(Checks.checkValueTypeEquals(pf.getReturnType(), rt2)))
                error(TYPEMISMATCHFUNCTIONCOMPOSITIONRETURN, FPMLPackage.Literals.PURE_FUNCTION_DEFINITION__RETURN_TYPE);
        }
    }

    @Check
    def FunctionCompositionReturnType(EffectFullFunctionDefinition ef){
        val rt = ef.getFunctionBody();
        if ( rt != null &&
        	rt instanceof CompositionFunctionBodyEffect && 
        	(rt as CompositionFunctionBodyEffect).returnFunction == null) {
            val rt2 = GetReturnType.getReturnTypeCompositionBodyEffect((rt as CompositionFunctionBodyEffect), ef.arg)
            if(!(Checks.checkTypeEquals(ef.returnType.type, rt2)))
                error(TYPEMISMATCHFUNCTIONCOMPOSITIONRETURN, FPMLPackage.Literals.EFFECT_FULL_FUNCTION_DEFINITION__RETURN_TYPE);
        }
    }

    @Check
    def FunctionCompositionArgType(PureFunctionDefinition pf){
        val rt = pf.getFunctionBody();
        if (rt != null && rt instanceof CompositionFunctionBodyPure) {
            val rt2 = Others.getFirstFunctionDefinitionFromCompositionBodyPure((rt as CompositionFunctionBodyPure))
            if((rt2 instanceof PureFunctionDefinition) && !(Checks.checkValueTypeEquals(pf.getArg().getType, GetArgType.getArgTypePure(rt2, pf.getArg().getType))))
                error(TYPEMISMATCHFUNCTIONCOMPOSITIONARGS, FPMLPackage.Literals.PURE_FUNCTION_DEFINITION__ARG);
        }
    }

    @Check
    def FunctionCompositionArgType(EffectFullFunctionDefinition ef){
        val rt = ef.getFunctionBody();
        if (rt != null && 
        	rt instanceof CompositionFunctionBodyEffect) {
	        val firstChainElement = Others.getFirstFunctionDefinitionFromCompositionBodyEffectFull((rt as CompositionFunctionBodyEffect))
	        if (firstChainElement instanceof PureFunctionDefinition || firstChainElement instanceof EffectFullFunctionDefinition) {
	            val t = ef.getArg().getType()
	            var Type t1
	            if (firstChainElement instanceof PureFunctionDefinition && t instanceof ValueType)
	            	t1 = GetArgType.getArgTypePure((firstChainElement as PureFunctionDefinition), (t as ValueType))
	            else if (firstChainElement instanceof EffectFullFunctionDefinition)
	            	t1 = GetArgType.getArgTypeEffectFull((firstChainElement  as EffectFullFunctionDefinition), t);
	            if(!(Checks.checkTypeEquals(t,t1)))
	                error(TYPEMISMATCHFUNCTIONCOMPOSITIONARGS, FPMLPackage.Literals.EFFECT_FULL_FUNCTION_DEFINITION__ARG);
	   		}
   		}
	}

    @Check
    def EffectFullArgumentUnitTypeNoID(EffectFullArgument efa){
        if (efa.getType() instanceof UnitType && efa.getName() != null)
            error(EFFECTFULLARGUMENTUNITTYPEID, FPMLPackage.Literals.EFFECT_FULL_ARGUMENT__TYPE);
    }

    @Check
    def MainFuncReturnTypeCheck(MainFunc m) {
        val rt = m.getFunctionBody();
        val arg = FPMLFactory.eINSTANCE.createEffectFullArgument()
        val  argType = FPMLFactory.eINSTANCE.createIOType()
        argType.type = FPMLFactory.eINSTANCE.createUnitType()
        if (rt instanceof CompositionFunctionBodyEffect) {
            val rt2 = GetReturnType.getReturnTypeCompositionBodyEffect(rt, arg)
            if(!(Checks.checkTypeEquals(m.getReturnType(), rt2)))
                error(TYPEMISMATCHFUNCTIONCOMPOSITIONRETURN, FPMLPackage.Literals.MAIN_FUNC__RETURN_TYPE);
        }
    }
    
    @Check
    def ValueDataTypeCheck(DataValue dv) {
    	if (!Checks.typeCheckDataAndValue(dv.value, dv.type.content))
    		error(TYPEVMISMATCHBETWEENVALUEANDDATA, FPMLPackage.Literals.DATA_VALUE__VALUE)
    }
    
    @Check
    def ApplyValueCheck(ApplyF a){
    	var CompositionFunctionBodyPure functionChain
    	if (a.eContainer instanceof CompositionFunctionBodyPure)
    		functionChain = (a.eContainer as CompositionFunctionBodyPure)
    	else
    		functionChain = (a.eContainer.eContainer as CompositionFunctionBodyPure)
    	val firstElement = Others.getFirstFunctionDefinitionFromCompositionBodyPure(functionChain)
    	val applyValueType = Others.getTypeFromExpression(a.value.value)
    	if (applyValueType != null) {
	    	if (EcoreUtil2.equals(firstElement, a)) {
	    		val functionDef = functionChain.eContainer
	    		switch functionDef {
	    			PureFunctionDefinition: {
	    				if (!Checks.checkTypeEquals(applyValueType, functionDef.arg.type)) {
	    					error(APPLYFUNCTIONTOWRONGVALUE, FPMLPackage.Literals.APPLY_F__VALUE)	
	    				}
	    			} 
	    		}	
	    	} else {
	    		val functionDef = functionChain.eContainer
	    		switch functionDef {
	    			PureFunctionDefinition: {
	   					val returnPreviousApplyElement = GetReturnType.getPreviousFunctionChainElementReturnType(functionChain.functionChain.map[x | Others.getFunctionDefinitionFromPureFactor(x)], a, firstElement, functionDef.arg)
	   					if (!Checks.checkTypeEquals(returnPreviousApplyElement, applyValueType))
	   						error(APPLYFUNCTIONTOWRONGVALUE, FPMLPackage.Literals.APPLY_F__VALUE)
	   				}
	    		}
       		}
       	}
    }
}