grammar it.unibo.FPML with org.eclipse.xtext.common.Terminals

generate fPML "http://www.unibo.it/FPML"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

///////////////////////////////////////////////////////////////
// Entry element
//////////////////////////////////////////////////////////////
Model:
	elements+=PureBlock
	elements+=EffectFullBlock;

//////////////////////////////////////////////////////////////
// Outer Blocks
//////////////////////////////////////////////////////////////

PureBlock:
	'Pure' '{'
		elements+=PureDataBlock
		elements+=PureFunctionBlock
	'}';

PureFunctionBlock:
	'Functions' '{'
		(features+=PureFunctionDefinition)*
	'}';

PureDataBlock:
	'Data' '{'
		(elements+=PureData)*
		value=PureValueBlock
	'}';

PureValueBlock:
	'Value' '{' 
		(elements+=PureValue)*
	'}'
;

EffectFullBlock:
    'Effects' '{'
    	elements+=EffectFullDataBlock
		elements+=EffectFullFunctionBlock
    '}';

EffectFullDataBlock:
		'Data' '{'
		(elements+=EffectFullData)*
		value=EffectFullValueBlock
	'}';

EffectFullValueBlock:
	'Value' '{' 
		(elements+=EffectFullValue)*
	'}'
;

EffectFullFunctionBlock:
	'Functions' '{'
    	(features+=EffectFullFunctionDefinition)*
		main=MainFunc
    '}';

/////////////////////////////////////////////////////////////////
// Outer Block Elements
/////////////////////////////////////////////////////////////////

PureData:
    name=ID ':' content=ValueType;

PureValue returns PureFunctionDefinition: {PureValue} name=ID ':' value=Expression;

EffectFullData: name=ID ':' content=EffectFullType;

EffectFullValue returns EffectFullFunctionDefinition: {EffectFullValue} name=ID ':' value=EffectFullExpression; 
   
PureFunctionDefinition:
	'def' returnType=ValueType name=ID '(' arg=Argument (',' higherOrderArg=AdditionalPureArgument)? ')' ':' '{' functionBody=FunctionBodyPure '}';

EffectFullFunctionDefinition:
	'def' returnType=IOType name=ID '(' arg=EffectFullArgument (',' higherOrderArg=AdditionalEffectFullArgument)? ')' ':' '{'  functionBody=FunctionBodyEffectFull '}';

MainFunc:
	'IO' returnType=UnitType 'main' ':' '{' functionBody=FunctionBodyEffectFull '}';

AdditionalPureArgument: arg2=Argument;
AdditionalEffectFullArgument: arg2=EffectFullArgument;

///////////////////////////////////////////////////////////////////////////////////////////////
// Aggregate Types
///////////////////////////////////////////////////////////////////////////////////////////////

Function: EffectFullFunction | PureFunction;

PureFunction: PureFunctionDefinition | PrimitivePureFunction | Argument;

EffectFullFunction: EffectFullFunctionDefinition | PrimitiveEffectFullFunction;

/*
 *  Tricky aggregate: is used in reference [] but has addictional components in order to 
 * 	facilitate the validation, those components suck as PrimitiveEffectFullValue or PrimitiveFunction
 * 	cannot be referenced because of no ids, but where the effectfullReference is used them are also allowed(not as reference).
 */
EffectFullReference: EffectFullValue | EffectFullArgument | PureValue | PrimitiveEffectFullValue | PrimitiveFunction | Function;

PrimitiveFunction: PrimitiveEffectFullFunction | PrimitivePureFunction | PrimitiveEffectFullValue;

///////////////////////////////////////////////////////////////////
// Function Body Elements
///////////////////////////////////////////////////////////////////


EffectFullArgument:
	type=Type name=ID;

Argument:
	type=ValueType name=ID;

FunctionBodyPure:
		 EmptyFunctionBody | CompositionFunctionBodyPure;

FunctionBodyEffectFull:
  	     EmptyFunctionBody | CompositionFunctionBodyEffect;

EmptyFunctionBody:
    {EmptyFunctionBody} 'Undefined';

CompositionFunctionBodyPure:
      referenceElement=[PureFunction] (functionChain+=CompositionFunctionBodyPureFactor)+ 
    | primitiveElement=PrimitivePureFunction (functionChain+=CompositionFunctionBodyPureFactor)+;
    
CompositionFunctionBodyPureFactor:
	  ( '|>' (referenceElement=[PureFunction]))
	| ( '|>' (PrimitiveElement=PrimitivePureFunction));

CompositionFunctionBodyEffect:
      referenceElement=[EffectFullReference] (functionChain+=CompositionFunctionBodyEffectFullFactor)+
    | primitiveElement=PrimitiveFunction (functionChain+=CompositionFunctionBodyEffectFullFactor)+;
    
CompositionFunctionBodyEffectFullFactor:
	  ( '>>=' (referenceElement=[EffectFullReference]))
	| ( '>>=' (PrimitiveElement=PrimitiveFunction));

//////////////////////////////////////////////////////////////////////
// Types
//////////////////////////////////////////////////////////////////////

IOType:
	'IO' type=Type ;

ValueType:
	IntegerType | StringType | DataType | PureFunctionType | PureAlgebraicType | UnitType;

Type:
	ValueType | EffectFullType;

EffectFullType:
	EffectFullFunctionType | EffectFullDataType | EffectFullAlgebraicType | IOType | VoidType;

VoidType: {VoidType};

IntegerType:
	{IntegerType} type="int";

StringType:
	{StringType} type="String";

UnitType:
	{UnitType} type="Unit";

DataType:
    {DataType} 'ref' type=[PureData];
  
EffectFullDataType:
    {EffectFullDataType} 'refIO' type=[EffectFullData];  
    
PureFunctionType:
	{PureFunctionType} 'F' '<' argType=ValueType ',' returnType=ValueType '>';

EffectFullFunctionType:
	{EffectFullFunctionType} 'FIO' '<' argType=Type ',' returnType=IOType '>';

PureAlgebraicType: '[' pureAdtElement1=ValueType pureAdtElement2=(PureSumTypeFactor | PureProdTypeFactor) ']';

PureSumTypeFactor:
    '+' adtElement=ValueType;
PureProdTypeFactor:
    '*' adtElement=ValueType;

EffectFullAlgebraicType: '[' effectFullAdtElement1=IOType effectFullAdtElement2=(EffectFullSumTypeFactor | EffectFullProdTypeFactor) ']';

EffectFullSumTypeFactor:
    '+' adtElement=IOType;
EffectFullProdTypeFactor:
    '*' adtElement=IOType;

////////////////////////////////////////////////////////////////////
// Values
////////////////////////////////////////////////////////////////////

EffectFullExpression:
	{RecursiveEffectFullExpression} 'IO' '[' exp=EffectFullExpression ']' 
	| 'IO' '(' Expression ')'  
	| EffectFullFunctionValue 
	| EffectFullDataValue
	| EffectFullProdValue
	| EffectFullSumValue
	| EffectFullValueRef;

	
UnitValue returns UnitType: {UnitType} '()';

EffectFullFunctionValue returns EffectFullFunctionType: value=EffectFullLambda;

EffectFullValueRef: {EffectFullValueRef} value=[EffectFullValue];

EffectFullLambda returns EffectFullFunctionDefinition: 
	{EffectFullLambda} '[' arg=EffectFullArgument ']' ':' '{' functionBody=CompositionFunctionBodyEffect '}'
	| {EffectFullLambda} '[' ']' ':' '{' functionBody=CompositionFunctionBodyEffect '}' ;

Expression:
    IntValue 
    | StringValue 
    | DataValue 
    | FunctionValue
    | UnitValue
    | PureValueRef
	| PureSumValue
	| PureProdValue;

IntValue returns IntegerType: {IntegerType} value=INT;

StringValue returns StringType: {StringType} value=STRING;

FunctionValue returns PureFunctionType: value=PureLambda;

DataValue returns DataType: {DataValue} type=[PureData]'(' value=Expression ')';

EffectFullDataValue returns EffectFullDataType: {EffectFullDataValue} type=[EffectFullData]'(' value=EffectFullExpression ')';

PureValueRef: {PureValueRef} value=[PureValue];

PureLambda returns PureFunctionDefinition: 
	{PureLambda} '(' arg=Argument ')' ':' '{' functionBody=CompositionFunctionBodyPure '}'
	| {PureLambda} '(' ')' ':' '{' functionBody=CompositionFunctionBodyPure '}'
;


PureProdValue: 
	'(' prodAdtElement1=Expression ',' prodAdtElement2=Expression ')';

PureSumValue:
	'Left' '(' sumAdtElement1=Expression ')'
	| 'Right' '(' sumAdtElement2=Expression ')';


EffectFullProdValue: 
	'(' prodAdtElement1=EffectFullExpression ',' prodAdtElement2=EffectFullExpression ')';

EffectFullSumValue:
	'Left' '(' sumAdtElement1=EffectFullExpression ')'
	| 'Right' '(' sumAdtElement2=EffectFullExpression ')';
    
    
/////////////////////////////////////////////////////////////////////
// Primitives
/////////////////////////////////////////////////////////////////////

PrimitivePureFunction: 
	IntToString | IntPow | Plus | Minus | Times | Mod | ApplyF | LeftPair | RightPair;

IntToString: {IntToString} 'intToString';
IntPow:	{IntPow} 'intPow';
Plus: {Plus} '+';
Minus: {Minus} '-';
Times: {Times} '*';
Mod: {Mod} 'mod';
LeftPair: {LeftPair} 'leftPair' type=PureAlgebraicType;
RightPair: {RightPair} 'rightPair' type=PureAlgebraicType;
ApplyF: {ApplyF} 'applyF' functionType=PureFunctionType value=ApplyFFactor;
ApplyFFactor:
	valueReference=[PureFunction]
	| '(' valueLambda=PureLambda ')'
;

PrimitiveEffectFullFunction:
	PrimitivePrint | ApplyFIO | PrimitiveReturn | LeftPairIO | RightPairIO;

PrimitivePrint:
    {PrimitivePrint} "print";

LeftPairIO: {LeftPairIO} 'leftPair' type=EffectFullAlgebraicType;
RightPairIO: {RightPairIO} 'rightPair' type=EffectFullAlgebraicType;

PrimitiveEffectFullValue:
	PrimitiveRandom  | PrimitiveTime;

PrimitiveRandom:
	{PrimitiveRandom} "randomInt";

PrimitiveReturn:
	{PrimitiveReturn} "return" type=Type;

PrimitiveTime: {PrimitiveTime} "currentTime";

ApplyFIO: {ApplyFIO} 'applyFIO' functionType=EffectFullFunctionType value=ApplyFIOFactor;
ApplyFIOFactor: 
	  valueReference=[EffectFullReference]
	| valuePrimitive=PrimitiveEffectFullValue
	| '(' valueLambda=EffectFullLambda ')';
    