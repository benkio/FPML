grammar it.unibo.FPML with org.eclipse.xtext.common.Terminals

generate fPML "http://www.unibo.it/FPML"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

///////////////////////////////////////////////////////////////
// Entry element
//////////////////////////////////////////////////////////////
Model:
	elements+=PureBlock
	elements+=EffectFullBlock;

//////////////////////////////////////////////////////////////
// Outer Blocks
//////////////////////////////////////////////////////////////

PureBlock:
	'Pure' '{'
		elements+=PureFunctionBlock
		elements+=DataBlock
	'}';

PureFunctionBlock:
	'Functions' '{'
		(features+=PureFunctionDefinition)*
	'}';

DataBlock:
	'Data' '{'
		(elements+=Data)*
		value=ValueBlock
	'}';

ValueBlock:
	'Value' '{' 
		(elements+=Value)*
	'}'
;

EffectFullBlock:
    'Effects' '{'
    	(features+=EffectFullFunctionDefinition)*
		main=MainFunc
    '}';

/////////////////////////////////////////////////////////////////
// Outer Block Elements
/////////////////////////////////////////////////////////////////

Data:
    name=ID ':' content=(AdtType);

Value: name=ID ':' value=Expression;

AdtType:
      ValueType
    | '[' adtElement1=AdtType adtElement2=(SumType | ProdType) ']';

SumType:
    '+' adtElement=AdtType;
ProdType:
    '*' adtElement=AdtType;
    
PureFunctionDefinition:
	'def' returnType=ValueType name=ID '(' arg=Argument ')' ':' '{' functionBody=FunctionBodyPure '}';

EffectFullFunctionDefinition:
	'def' returnType=IOType name=ID '(' arg=EffectFullArgument ')' ':' '{'  functionBody=FunctionBodyEffectFull '}';

MainFunc:
	'IO' returnType=UnitType 'main' ':' '{' functionBody=FunctionBodyEffectFull '}';

///////////////////////////////////////////////////////////////////
// Function Body Elements
///////////////////////////////////////////////////////////////////

ChainElement:
    PureFunctionDefinition | EffectFullFunctionDefinition | Value | EffectFullArgument;

InitialPureChainElement:
	PureFunctionDefinition | Value ;

EffectFullArgument:
	type=Type name=ID;

Argument:
	type=ValueType name=ID;

FunctionBodyPure:
		 EmptyFunctionBody | CompositionFunctionBodyPure;

FunctionBodyEffectFull:
  	     EmptyFunctionBody | CompositionFunctionBodyEffect;

EmptyFunctionBody:
    {EmptyFunctionBody} 'Undefined';

CompositionFunctionBodyPure:
      referenceElement=[InitialPureChainElement] (functionChain+=CompositionFunctionBodyPureFactor)+ (returnFunction=ReturnPureFunction)?
    | primitiveElement=PrimitivePureFunction (functionChain+=CompositionFunctionBodyPureFactor)+ (returnFunction=ReturnPureFunction)?;
    
CompositionFunctionBodyPureFactor:
	  ( '|>' (referenceElement=[PureFunctionDefinition]))
	| ( '|>' (PrimitiveElement=PrimitivePureFunction));

CompositionFunctionBodyEffect:
      referenceElement=[ChainElement] (functionChain+=CompositionFunctionBodyEffectFullFactor)+ (returnFunction=ReturnEffectFullFunction)?
    | primitiveElement=PrimitiveEffectFullFunction (functionChain+=CompositionFunctionBodyEffectFullFactor)+ (returnFunction=ReturnEffectFullFunction)?;
    
CompositionFunctionBodyEffectFullFactor:
	  ( '>>=' (referenceElement=[ChainElement]))
	| ( '>>=' (PrimitiveElement=(PrimitiveEffectFullFunction | PrimitivePureFunction)));

ReturnPureFunction:
	'->' '(' lambdaFunctionBody=PureLambda ')';

ReturnEffectFullFunction:
	'->' '(' lambdaFunctionBody=EffectFullLambda ')';

//////////////////////////////////////////////////////////////////////
// Types
//////////////////////////////////////////////////////////////////////

IOType:
	'IO' type=Type ;

ValueType:
	IntegerType | StringType | DataType | PureFunctionType;

Type:
	ValueType | UnitType | EffectFullFunctionType;

IntegerType:
	{IntegerType} type="int";

StringType:
	{StringType} type="String";

UnitType:
	{UnitType} type="Unit";

DataType:
    {DataType} 'ref' type=[Data];
    
PureFunctionType:
	{PureFunctionType} 'F' '<' argType=ValueType ',' returnType=ValueType '>';

EffectFullFunctionType:
	{EffectFullFunctionType} 'FIO' '<' argType=Type ',' returnType=IOType '>';

////////////////////////////////////////////////////////////////////
// Values
////////////////////////////////////////////////////////////////////

Expression:
    IntValue | StringValue | UnitValue | DataValue | FunctionValue ;

IntValue returns IntegerType: {IntegerType} value=INT;

StringValue returns StringType: {StringType} value=STRING;

UnitValue returns UnitType: {UnitType} '()';

FunctionValue returns PureFunctionType: value=PureLambda;

DataValue returns DataType: {DataValue} type=[Data]'(' value=AdtValue ')';

ValueRef:
	{ValueRef} value=[Value]
;

PureLambda: '(' arg=Argument ')' ':' functionBody=FunctionBodyPure;

EffectFullLambda: '(' arg=EffectFullArgument ')' ':' functionBody=FunctionBodyEffectFull;

AdtValue:
	  IntValue
	| StringValue
	| ValueRef
	| DataValue
	| SumValue
	| FunctionValue
	| ProdValue;

ProdValue: 
	'(' prodAdtElement1=AdtValue ',' prodAdtElement2=AdtValue ')';

SumValue:
	'Left' '(' sumAdtElement1=AdtValue ')'
	| 'Right' '(' sumAdtElement2=AdtValue ')';
    
/////////////////////////////////////////////////////////////////////
// Primitives
/////////////////////////////////////////////////////////////////////

PrimitivePureFunction returns PureFunctionDefinition: 
	IntToString | IntPow
;

IntToString:
	{IntToString} 'IntToString';

IntPow:
	{IntPow} 'IntPow'
;

PrimitiveEffectFullFunction returns EffectFullFunctionDefinition:
	PrimitivePrint;

PrimitivePrint:
    {PrimitivePrint} "print";
    